---
show: step
version: 1.0 
---

## 课程介绍

本课程将介绍SequoiaDB中的Lob对象的支持的分区类型和使用方式。

数据分区有两种类型：水平分区和垂直分区。

**水平分区** [水平分区](http://doc.sequoiadb.com/cn/SequoiaDB-cat_id-1432190844-edition_id-304)又称为数据库分区或横向分区。

在 SequoiaDB 集群环境中，用户可以通过将一个集合中的数据切分到多个复制组中，以达到并行计算的目的。这种数据切分的方式称为水平分区。水平分区是按一定的条件把全局关系的所有元组划分成若干不相交的子集，每个子集为关系的一个片段，称为分区。对于水平分区后的每一个分区，该分区只存在于集群的某一个复制组中。但一个复制组却可以承载水平分区后的多个分区。分区在复制组之间可以通过水平切分操作进行移动。

![sh3](http://doc.sequoiadb.com/cn/index/Public/Home/images/304/basic_operation/sharding/sh3.jpg)



**垂直分区** 垂直分区又称为集合分区或纵向分区。

在 SequoiaDB 集群环境中，用户也可以将一个集合全局关系的属性分成若干子集，并在这些子集上作投影运算，将这些子集映射到另外的集合上，从而实现集合关系的垂直切分。该集合称之为主集合，每个切分的子集称为分区，分区映射的集合称为子集合。一个分区只能映射到一个子集合中，但一个子集合可以承载多个分区。分区在子集合之间可以通过垂直切分操作进行重映射。



![sh4](http://doc.sequoiadb.com/cn/index/Public/Home/images/304/basic_operation/sharding/sh4.jpg)

**分区方式**

数据分区有两种方式：范围分区（Range）和散列分区（Hash）。水平分区既可使用 Hash 方式也可使用 Range 方式进行数据分区；垂直分区只能使用 Range 方式进行数据分区。Hash 及 Range 这两种分区方式判定分区划分所依据的字段称为“[分区键](http://doc.sequoiadb.com/cn/SequoiaDB-cat_id-1432190616-edition_id-304)”。分区键基于集合定义，每个分区键可以包含一个或多个字段。

Range 方式和 Hash 方式主要区别如下： Range 方式下依据记录中分区键的范围选择所要插入的分区，而 Hash 方式下则根据记录中分区键生成的 Hash 值选择所要插入的分区。ShardingType 如果不填则默认为 Hash 分区。



![sharding_concept](http://doc.sequoiadb.com/cn/index/Public/Home/images/304/basic_operation/sharding/sharding_concept.jpg)



在所示图中，为一个 Range 方式分区，方形区域为三个分别位于不同数据组的数据节点，椭圆形为协调节点。每个数据节点各自定义了所包含数据的范围。例如对于节点 1 包含了大于等于 0 切小于 10 的数据。

当用户插入一条数据时，协调节点首先判定该数据的分区键应当坐落于哪个分区。如果分区键不存在则定义为 Undefined 类型（Undefined 类型也可以与普通数据类型进行对比）。

当查询到该数据所在的分区后，协调节点会将请求直接下发给指定的分区。

而在 Hash 方式分区中，用户不指定每个分区的范围，而是指定集合切分的分区个数（Partition），其值必须是 2 的幂，范围在[ 23 , 220 ]，默认为 4096 个，代表我们将整个范围平均划分为 4096 个分区。设计 Hash 分区的目的是让数据分布更灵活，可以根据需要自由设置每个数据分区承担 Hash 分区的范围。

#### LOB 开发简介

SequoiaDB 巨杉数据库为应用提供通过 SDK 驱动进行数据库操作和集群操作的接口。

#### 实验流程简述：

- 用户通过 IDEA 编辑器编写 Java 源码
- 实验相关核心代码，可从文档中的代码示例粘贴到项目指定文件的 TODO 标记处
- 通过编译、运行 Java 代码，操作 SequoiaDB 数据库 JSON 实例

![](https://doc.shiyanlou.com/courses/1736/1207281/7b1731fc121e3b460dcd9841eb0218a6-0)

#### 实验环境

课程使用的实验环境为 Ubuntu Linux 16.04 64 位版本。SequoiaDB 数据库引擎为 3.4 版本。IDEA 编辑器为 16.0 版本。JDK 为 1.8 版本。

## 打开项目

#### 打开 IDEA

打开 IDEA 代码开发工具。

![](https://doc.shiyanlou.com/courses/1736/1207281/06650396616c742995bb63fcf933fac5-0)

#### 打开项目

打开object-java项目

![image-20200414091915064](https://doc.shiyanlou.com/courses/1737/1207281/79e3fad2d27f14cfcbc94eadd646d88d-0)

#### 打开 Package

打开lesson5_lob_partion包，在该Package完成后续课程

![image-20200415100711419](https://doc.shiyanlou.com/courses/1737/1207281/5cb360ac58de894600859a77f61b87f4-0)

## 水平分区的创建

水平分区既可使用 Hash 方式也可使用 Range 方式进行数据分区，但对于LOB对象，在水平分区类型中只适合于Hash分区。在下面的例子中，使用Hash 分区方式，分区个数为 4096，分区键为sid。然而对于LOB对象，它的分区键是OID 加分片序号，通过Hash分散存储在相应的分区组中。其哈希空间与所属集合的哈希空间相同。

Hash 方式下根据记录中分区键生成的 Hash 值选择所要插入的分区。ShardingType 如果不填则默认为 Hash 分区。

在 Hash 方式分区中，用户不指定每个分区的范围，而是指定集合切分的分区个数（Partition），其值必须是 2 的幂，范围在[ 23 , 220 ]，默认为 4096 个，代表我们将整个范围平均划分为 4096 个分区。设计 Hash 分区的目的是让数据分布更灵活，可以根据需要自由设置每个数据分区承担 Hash 分区的范围。

#### 创建水平分区集合

可以通过Java SDK提供的createCollection(String collectionName, BSONObject options)接口创建执行属性的集合。

1）双击打开类LobPartitonUtil，找到createHashCL()函数内的行**TODO 创建分区方式为Hash的集合**

![image-20200415001632676](https://doc.shiyanlou.com/courses/1737/1207281/95ee68af0a81c2d914f5caabeb31aae5-0)

2）将下方代码粘贴到TODO ~ TODO END区域内第26行

```java
Sequoiadb sequoiadb = this.getSdbConnect();
CollectionSpace cs = sequoiadb.createCollectionSpace(csName);
BasicBSONObject cl_options = new BasicBSONObject();
//set collection params
cl_options.put("ShardingType","hash");
cl_options.put("ShardingKey",new BasicBSONObject("sid",1));
cl_options.put("Partition",4096);
cl_options.put("AutoSplit",true);
//create collection
cs.createCollection(clName,cl_options);
```

## 查看水平分区集合

执行上一步编写的创建水平分区集合代码，然后查询该集合的编目数据，查看水平集合的分区实现。

#### 执行代码

1）鼠标移动到屏幕左边LobPartitonTest类，右键点击，出现如图所示的选项条，左键单击**Edit 'LobPartitonTest'**选项

![image-20200414222930024](https://doc.shiyanlou.com/courses/1737/1207281/61fff4148d169ccc82f16aae75ab68bc-0)

2）在出现下图所示界面后，将**CreateHash**填入红框所选位置，然后点击**OK**按钮

![image-20200414223015517](https://doc.shiyanlou.com/courses/1737/1207281/68888c0ed868ade99b0869354b05d034-0)

3）鼠标移动到屏幕左边LobPartitonTest类上，右键点击，出现如图所示的选项条，左键单击**Run 'LobPartitonTest'**选项

![image-20200414223049009](https://doc.shiyanlou.com/courses/1737/1207281/733c786d8d3b548a4ace7b6d1300bcaf-0)

4）在屏幕下方查看结果输出，enter代表开始此项操作，exit代表结束这项操作，两者中间是执行中的输出信息。

![image-20200414223155501](https://doc.shiyanlou.com/courses/1737/1207281/34a1f1f8c73ed13bd1ae9e691b6fcf3f-0)

查看结果的后半部分，可以看到CataInfo字段，里面存储的是Hash分区和数据组的对应关系。下面的结果就说明group1负责存储Hash值为[0,1365)的数据。当向该集合中上传LOB时，将LOB对象的OID 加分片序号Hash后存放到相应的数据组内。

![image-20200414223349025](https://doc.shiyanlou.com/courses/1737/1207281/561f54b6c2966d265948381a6111126c-0)



## 垂直分区的创建

垂直分区分为主集合和子集合，主集合必须用 Range 切分，子集合既可用 Range，也可用 Hash，ShardingKey 也不必和主表的一致

#### 创建垂直分区集合步骤

垂直分区的创建分为以下几个步骤

1 创建主表，主表必须是Range分区类型

2 创建子表

3 将子表 1、子表 2 关联到主表中

每个子表都有一个范围，对于用途为存放LOB的集合，该范围为时间范围。插入LOB对象时插入主表，这时会通过LOB对象的LOBID判断该LOB上传的时间，进而判断该插入到哪一个子表中。

#### 创建主表

1）双击打开LobPartitonUtil类，在createMainCL()函数中找到行 **TODO 创建分区方式为Range的主集合**

![image-20200415002431204](https://doc.shiyanlou.com/courses/1737/1207281/f73c2e45fdc5a95bf3f6ea56d2ca0dd1-0)

2）将下方代码粘贴到TODO ~ TODO END区域的第51行

```java
/**
* Create the main collection, and the main table must be divided with range
*/
Sequoiadb sequoiadb = this.getSdbConnect();
sequoiadb.createCollectionSpace(csName);
BasicBSONObject mainOptions = new BasicBSONObject();
// Use the field date as the main collection partition key, and this field is date type.
mainOptions.put("ShardingKey",new BasicBSONObject("date",1));
mainOptions.put("ShardingType", "range");
//Claim the main collection
mainOptions.put("IsMainCL", true);
mainOptions.put("LobShardingKeyFormat","YYYYMMDD");
DBCollection mainCL = sequoiadb.getCollectionSpace(csName).createCollection(mainClName, mainOptions);
```

#### 创建子表

1）双击打开LobPartitonUtil类，在createSubCL()函数中找到行 **TODO 创建分区方式为Hash的子集合**

![image-20200415003249895](https://doc.shiyanlou.com/courses/1737/1207281/8d3f6e756bba379746b9293d31195b6b-0)

2）将下方代码粘贴到TODO ~ TODO END区域的第69行

```java
BasicBSONObject subOptions = new BasicBSONObject();
//Set the partition key
subOptions.put("ShardingKey",new BasicBSONObject("date",1));
//Set the partition method
subOptions.put("ShardingType", "hash");
DBCollection subCL1 = sequoiadb.getCollectionSpace(csName).createCollection(slaveClName, subOptions);
```

#### 挂载子表

挂载子表是需要指定子表的全名称，也就是主集合.子集合。同时还需要设置子表的上下边界，这个边界为左闭右开。

1）双击打开LobPartitonUtil类，在attachSubToMain()函数中找到行 **TODO 将子表挂载到主表**

![image-20200415003544062](https://doc.shiyanlou.com/courses/1737/1207281/73a73ad43a78e8581c6399e192ae796c-0)

2）将下方代码粘贴到TODO ~ TODO END区域的第79行

```java
Sequoiadb sequoiadb = this.getSdbConnect();
//The parameters when mounting are mainly the upper and lower boundaries of the sub-table settings
BasicBSONObject attachOptions = new BasicBSONObject();
attachOptions.put("LowBound", new BasicBSONObject("date", lowBound));
attachOptions.put("UpBound", new BasicBSONObject("date", upBound));
//Get the main table object
DBCollection mainCL = sequoiadb.getCollectionSpace(mainCsName).getCollection(mainClName);
//Get the subtable object
DBCollection subCL = sequoiadb.getCollectionSpace(slaveCsName).getCollection(slaveClName);
//Mount the subtable to the main table
mainCL.attachCollection(subCL.getFullName(), attachOptions);
```

## 查看垂直分区集合

依次调用在上一小节中编写的分步创建垂直分区集合的函数，然后查看垂直分区的挂载结果。

#### 执行代码

1）鼠标移动到屏幕左边LobPartitonTest类，右键点击，出现如图所示的选项条，左键单击**Edit 'LobPartitonTest'**选项

![image-20200414222930024](https://doc.shiyanlou.com/courses/1737/1207281/61fff4148d169ccc82f16aae75ab68bc-0)

2）在出现下图所示界面后，将**CreateHash**填入红框所选位置，然后点击**OK**按钮

![image-20200415010844334](https://doc.shiyanlou.com/courses/1737/1207281/8393bbde7cd3b422a669aad662807bab-0)

3）鼠标移动到屏幕左边LobPartitonTest类上，右键点击，出现如图所示的选项条，左键单击**Run 'LobPartitonTest'**选项

![image-20200414223049009](https://doc.shiyanlou.com/courses/1737/1207281/733c786d8d3b548a4ace7b6d1300bcaf-0)

4）在屏幕下方查看结果输出，enter代表开始此项操作，exit代表结束这项操作，两者中间是执行中的输出信息。

![image-20200415010945683](https://doc.shiyanlou.com/courses/1737/1207281/1ddedd08cf4d7c38e08f58c240b4bdf1-0)

从结果中可以看到，集合名称为school.student，分区方式为Range，在该集合上面挂载了两个子集合，其中一个是school.student_202001，该子集合所负责的时间范围为[20200101,20200201)。

![image-20200415011424050](https://doc.shiyanlou.com/courses/1737/1207281/5e5222cddecbb98668e00e10e30aa8f7-0)

![image-20200415011059675](https://doc.shiyanlou.com/courses/1737/1207281/72e8ce98cea4660d5cd4c44b157a7394-0)

