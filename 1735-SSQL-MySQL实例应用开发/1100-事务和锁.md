---
show: step
version: 1.0 

---

## 课程介绍

本课程将带领您在已经部署 SequoiaDB 巨杉数据库引擎及创建了 MySQL 实例的环境中，熟悉MySQL的事务和锁机制

#### 请点击右侧选择使用的实验环境

#### 实验环境

课程使用的实验环境为 Ubuntu Linux 16.04 64 位版本。SequoiaDB 数据库引擎以及 SequoiaSQL-MySQL 实例均为 3.4 版本。

#### 概述

**事务**

MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务。

**锁**

锁是计算机协调多个进程或纯线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所在有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

## 打开项目

#### 打开idea

打开idea代码开发工具

![1735-110-1.png](https://doc.shiyanlou.com/courses/1735/1207281/6f87a8c93937c3c51f6d4839559de710-0)

#### 打开SSQL-MySQL项目

打开SSQL-MySQL项目，在该课程中完成后续试验

![1735-110-13.png](https://doc.shiyanlou.com/courses/1735/1207281/40a9e7b6fbd5c3853dc09f69d0a06c86-0)

#### 打开lesson10_transactionAndLock包

打开lesson10_transactionAndLock packge，在该packge中完成后续课程。

![1735-1100-1.png](https://doc.shiyanlou.com/courses/1735/1207281/8489ab84f41210e2a0703700542bfbfb-0)

## 事务控制

使用Connection对象来管理事务。java.sql.Connection接口是一个数据库连接对象。它与特定数据库的连接（会话）。执行SQL语句并在连接的上下文中返回结果。

- 开启事务

  setAutoCommit(boolean autoCommit)
  调用该方法设置参数为false，即开启事务

- 提交事务

  commit()
  当所有sql斗执行完提交事务

- 回滚事务

  rollback()
  在catch中回滚事务

有如下一个MySQL数据表，利用Java程序：把id=1对应的余额减少500，id=2对应的余额增加500

打开TransactionTest

![1587285384509](C:\Users\ChengYueyi\AppData\Roaming\Typora\typora-user-images\1587285384509.png)

修改run方法第11行TODO中的内容为

```java
//1.开启事务
conn.setAutoCommit(false);
stmt = conn.createStatement();
//2.模拟转帐，id为1的用户余额减少500，id为2的用户余额增加500
String sql1 = "update account set balance = balance - 500 where id = 1";
String sql2 = "update account set balance = balance + 500 where id = 2";
stmt.executeUpdate(sql1);
stmt.executeUpdate(sql2);
//3.提交事务
conn.commit();
//4.查看转帐结果
stmt = conn.createStatement();
String sql = "SELECT * from account;";
rs = stmt.executeQuery(sql);
while (rs.next()) {
    for (int i = 1; i <= rs.getMetaData().getColumnCount() ; i++) {
        System.out.print(rs.getString(i)+"\t");
    }
    System.out.println();
}
```

![1587285721851](C:\Users\ChengYueyi\AppData\Roaming\Typora\typora-user-images\1587285721851.png)

打开TransLockMainTest

![1587285512936](C:\Users\ChengYueyi\AppData\Roaming\Typora\typora-user-images\1587285512936.png)

修改transactionTest方法的第104行TODO中的内容为

```java
conn.rollback();
```

![1587285537439](C:\Users\ChengYueyi\AppData\Roaming\Typora\typora-user-images\1587285537439.png)

右键TransLockMainTest，选择Edit，修改参数为transaction

![1735-1100-3.png](https://doc.shiyanlou.com/courses/1735/1207281/88b4488ff1969ca405d42cf6707fab5a-0)

![1735-1100-4.png](https://doc.shiyanlou.com/courses/1735/1207281/3e26c7be96183e4b2eb66b4fb2471ddf-0)

右键TransLockMainTest，选择Run，执行代码

![1735-1100-5.png](https://doc.shiyanlou.com/courses/1735/1207281/c00ee28d4199589a0845bf25aa9235a6-0)

查看结果

​			![1587285755398](C:\Users\ChengYueyi\AppData\Roaming\Typora\typora-user-images\1587285755398.png)

模拟转帐失败，事务回滚场景

打开TransactionTest

![1587285384509](C:\Users\ChengYueyi\AppData\Roaming\Typora\typora-user-images\1587285384509.png)

修改run方法第11行TODO中的内容为

```java
//1.开启事务
conn.setAutoCommit(false);
stmt = conn.createStatement();
//2.模拟转帐，id为1的用户余额减少500，id为2的用户余额增加500
String sql1 = "update account set balance = balance - 500 where id = 1";
String sql2 = "update account set balance = balance + 500 where id = 2";
stmt.executeUpdate(sql1);
int ii = 1 / 0; //模拟异常
stmt.executeUpdate(sql2);
//3.提交事务
conn.commit();
//4.查看转帐结果
stmt = conn.createStatement();
String sql = "SELECT * from account;";
rs = stmt.executeQuery(sql);
while (rs.next()) {
    for (int i = 1; i <= rs.getMetaData().getColumnCount() ; i++) {
        System.out.print(rs.getString(i)+"\t");
    }
    System.out.println();
}
```

右键TransLockMainTest，选择Run，执行代码

![img](https://doc.shiyanlou.com/courses/1735/1207281/c00ee28d4199589a0845bf25aa9235a6-0)

程序报错，最终转帐过程回滚

## 事务原子性

> 事务内的每个内容不可分割，是一个统一的整体。或同时进行或同时消亡。
>
> 验证步骤：写入两条记录分别存放在不同物理服务器，执行更新操作并rollback，确保数据恢复原始状态

环境中已经创建了employee表，表中记录分别存放在不同物理服务器

打开AtomicityTest.java，

![1587286379451](C:\Users\ChengYueyi\AppData\Roaming\Typora\typora-user-images\1587286379451.png)

修改第18行，query方法的TODO

```java
stmt = conn.createStatement();
String sql = "SELECT * from employee;";
rs = stmt.executeQuery(sql);
while (rs.next()) {
    for (int i = 1; i <= rs.getMetaData().getColumnCount() ; i++) {
        System.out.print(rs.getString(i)+"\t");
    }
    System.out.println();
}
```

![1587286412486](C:\Users\ChengYueyi\AppData\Roaming\Typora\typora-user-images\1587286412486.png)

打开AtomicityTest.java，修改第11行update方法的TODO

```java
conn.setAutoCommit(false);
stmt = conn.createStatement();
String sql1 = "update employee set age = 28 where empno = 10001";
String sql2 = "update employee set age = 20 where empno = 10004";
stmt.executeUpdate(sql1);
stmt.executeUpdate(sql2);
conn.rollback();
```

右键TransLockMainTest，选择Edit，修改参数为atomicity

![1735-1100-3.png](https://doc.shiyanlou.com/courses/1735/1207281/88b4488ff1969ca405d42cf6707fab5a-0)

右键TransLockMainTest，选择Run，执行代码

![1735-1100-5.png](https://doc.shiyanlou.com/courses/1735/1207281/c00ee28d4199589a0845bf25aa9235a6-0)

查看结果，发现前后数据一致

## 悲观锁

悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

#### 使用场景举例

商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单时必须确保该商品status为1。假设商品的id为1。

#### 1.如果不采用锁，那么操作方法如下

```sql
//1.查询出商品信息
select status from t_goods where id=1;

//2.根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);

//3.修改商品status为2
update t_goods set status=2;
```

上面这种场景在高并发访问的情况下很可能会出现问题。

前面已经提到，只有当goods status为1时才能对该商品下单，上面第一步操作中，查询出来的商品status为1。但是当我们执行第三步Update操作的时候，有可能出现其他人先一步对商品下单把goods status修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得数据不一致。所以说这种方式是不安全的。

#### 2.使用悲观锁来实现

在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出goods信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么在这个过程中，因为goods被锁定了，就不会出现有第三者来对其进行修改了。

注：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。

我们可以使用命令设置MySQL为非autocommit模式：

set autocommit=0;

设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：

```sql
//0.开始事务
begin;/begin work;/start transaction; (三者选一就可以)

//1.查询出商品信息
select status from t_goods where id=1 for update;

//2.根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);

//3.修改商品status为2
update t_goods set status=2;

//4.提交事务
commit;/commit work;
```

注：上面的begin/commit为事务的开始和结束，因为在前一步我们关闭了mysql的autocommit，所以需要手动控制事务的提交，在这里就不细表了。

上面的第一步我们执行了一次查询操作：select status from t_goods where id=1 for update;

与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。
