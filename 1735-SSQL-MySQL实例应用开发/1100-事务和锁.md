---
show: step
version: 1.0 
---

## 课程介绍

本课程将带领您在已经部署 SequoiaDB 巨杉数据库引擎及创建了 SequoiaSQL-MySQL 实例的环境中，熟悉 MySQL 的事务和锁机制。

#### 请点击右侧选择使用的实验环境

#### 部署架构：

本课程中 SequoiaDB 巨杉数据库的集群拓扑结构为三分区单副本，其中包括：1个 SequoiaSQL-MySQL 数据库实例节点、1个引擎协调节点，1个编目节点与3个数据节点。

![图片描述](https://doc.shiyanlou.com/courses/1469/1207281/8d88e6faed223a26fcdc66fa2ef8d3c5)

详细了解 SequoiaDB 巨杉数据库系统架构：

- [SequoiaDB 系统架构](http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1519649201-edition_id-0)

#### 实验环境

课程使用的实验环境为 Ubuntu Linux 16.04 64 位版本。SequoiaDB 数据库引擎以及 SequoiaSQL-MySQL 实例均为 3.4 版本。

#### 概述

**事务**

MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务。

**锁**

锁是计算机协调多个进程或多线程并发访问某一资源的机制。在数据库中，除传统的计算资源（ CPU、RAM、I/O ）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所在有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

## 打开项目

#### 打开idea

打开 idea 代码开发工具

![1735-110-1.png](https://doc.shiyanlou.com/courses/1735/1207281/6f87a8c93937c3c51f6d4839559de710-0)

#### 打开SSQL-MySQL项目

打开 SSQL-MySQL 项目，在该课程中完成后续试验

![1735-110-13.png](https://doc.shiyanlou.com/courses/1735/1207281/40a9e7b6fbd5c3853dc09f69d0a06c86-0)

#### 打开lesson10_transactionAndLock包

打开 lesson10_transactionAndLock packge ，在该packge中完成后续课程

![1735-1100-1.png](https://doc.shiyanlou.com/courses/1735/1207281/8489ab84f41210e2a0703700542bfbfb-0)

## 事务控制

使用 Connection 对象来管理事务。java.sql.Connection 接口是一个数据库连接对象。

- 开启事务

  setAutoCommit(boolean autoCommit)
  调用该方法设置参数为false，即开启事务

- 提交事务

  commit()
  当所有sql斗执行完提交事务

- 回滚事务

  rollback()
  在catch中回滚事务

1）打开 TransactionTest.java
2）把 id=1 对应的余额减少 500 ，id=2 对应的余额增加500，修改 run 方法的 TODO code 1中代码为

```java
//1.开启事务
conn.setAutoCommit(false);
stmt = conn.createStatement();
//2.模拟转帐，id为1的用户余额减少500，id为2的用户余额增加500
String sql1 = "UPDATE account SET balance = balance - 500 WHERE id = 1";
String sql2 = "UPDATE account SET balance = balance + 500 WHERE id = 2";
stmt.executeUpdate(sql1);
stmt.executeUpdate(sql2);
//3.提交事务
conn.commit();
//4.查看转帐结果
stmt = conn.createStatement();
String sql = "SELECT * FROM account;";
rs = stmt.executeQuery(sql);
while (rs.next()) {
    for (int i = 1; i <= rs.getMetaData().getColumnCount() ; i++) {
        System.out.print(rs.getString(i)+"\t");
    }
    System.out.println();
}
```

3）修改参数，右键 TransLockMainTest.java，选择 Edit 'TransLockMainT...main()'
4）修改参数为 transaction
5）执行代码，右键 TransLockMainTest.java，选择 Run 'TransLockMainT...main()'，运行代码
6）查看结果

​			![1587285755398](C:\Users\ChengYueyi\AppData\Roaming\Typora\typora-user-images\1587285755398.png)

## 事务原子性

事务内的每个内容不可分割，是一个统一的整体，或同时进行或同时消亡。

验证步骤：写入两条记录分别存放在不同物理服务器，执行更新操作并 rollback ，确保数据恢复原始状态

> 环境中已经创建了 employee 表，表中记录分别存放在不同物理服务器
>

1）打开 AtomicityTest.java
2）查看初始数据，修改 query 方法的 TODO code 1中代码为

```java
//创建一个 Statement 对象来将 SQL 语句发送到数据库
stmt = conn.createStatement();
//编写 sql
String sql = "SELECT * FROM employee;";
rs = stmt.executeQuery(sql);
while (rs.next()) {
    for (int i = 1; i <= rs.getMetaData().getColumnCount() ; i++) {
        System.out.print(rs.getString(i)+"\t");
    }
    System.out.println();
}
```

3）开启事务执行更新操作，并 rollback，修改 update 方法的 TODO code 2中代码为：

```java
//关闭自动提交
conn.setAutoCommit(false);
//创建一个 Statement 对象来将 SQL 语句发送到数据库
stmt = conn.createStatement();
String sql1 = "UPDATE employee SET age = 28 WHERE empno = 10001";
String sql2 = "UPDATE employee SET age = 20 WHERE empno = 10004";
stmt.executeUpdate(sql1);
stmt.executeUpdate(sql2);
conn.rollback();
```

3）修改参数，右键 TransLockMainTest.java，选择 Edit 'TransLockMainT...main()'

![1735-1100-3.png](https://doc.shiyanlou.com/courses/1735/1207281/88b4488ff1969ca405d42cf6707fab5a-0)

4）修改参数为 atomicity
5）执行代码，右键 TransLockMainTest.java，选择 Run 'TransLockMainT...main()'，运行代码

![1735-1100-5.png](https://doc.shiyanlou.com/courses/1735/1207281/c00ee28d4199589a0845bf25aa9235a6-0)

6）查看结果

查看结果，发现前后数据一致

## 事务隔离性

事务的隔离性指的是几个事务同时执行，事务 a 不应该干扰到事务 b 内的操作（在并发过程中很有可能会发生事务间的影响，例如脏读、不可重复读等。需要在编程的时候选择适当的方式进行选择）

验证步骤：

1.开启事务 A

2.开始事务 B

3.在事务 B 中修改一条记录，不提交

4.在事务 A 中查看该条数据是否变化

5.提交事务 B

6.在事务 A 中查看该条数据是否变化

1）打开 IsolationTest.java
2）查看数据，修改 query 方法的 TODO code 1中代码为

```java
//创建一个 Statement 对象来将 SQL 语句发送到数据库
stmt = conn.createStatement();
//编写 sql
String sql = "SELECT * FROM employee;";
rs = stmt.executeQuery(sql);
while (rs.next()) {
    for (int i = 1; i <= rs.getMetaData().getColumnCount() ; i++) {
        System.out.print(rs.getString(i)+"\t");
    }
    System.out.println();
}
```

3）模拟事务B中修改一条记录，修改 update 方法的 TODO code 2中代码为

```
//创建一个 Statement 对象来将 SQL 语句发送到数据库
stmt = conn.createStatement();
//编写 sql
String sql1 = "UPDATE employee SET age = 28 WHERE empno = 10001";
stmt.executeUpdate(sql1);
```

4）打开 TransLockMainTest.java 

5）测试事务隔离性，修改 isolationTest 方法的 TODO code 1代码为

```java
System.out.println("事务A中的employee的初始数据：");
//查询初始数据
IsolationTest.query(conn, stmt, rs);
//开启事务A，开启事务B
conn.setAutoCommit(false);
conn2.setAutoCommit(false);
//更新事务B中的一条数据
IsolationTest.update(conn2,stmt,rs);
System.out.println("事务B未提交时，事务A中的employee的数据为：");
IsolationTest.query(conn, stmt, rs);
//提交事务B
conn2.commit();
System.out.println("事务B提交后，事务A中的employee的数据为：");
IsolationTest.query(conn, stmt, rs);
```

3）修改参数，右键 TransLockMainTest.java，选择 Edit 'TransLockMainT...main()'

![1735-1100-3.png](https://doc.shiyanlou.com/courses/1735/1207281/88b4488ff1969ca405d42cf6707fab5a-0)

4）修改参数为 isolation
5）执行代码，右键 TransLockMainTest.java，选择 Run 'TransLockMainT...main()'，运行代码

![1735-1100-5.png](https://doc.shiyanlou.com/courses/1735/1207281/c00ee28d4199589a0845bf25aa9235a6-0)

6）查看结果

## 悲观锁

悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

#### 使用场景举例

商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单时必须确保该商品status为1。假设商品的id为1。

#### 1.如果不采用锁，那么操作方法如下

1. 查询出商品信息
   SELECT status FROM t_goods WHERE id=1;
2. 根据商品信息生成订单
   INSERT INTO t_orders (id,goods_id) VALUES (null,1);
3. 修改商品 status 为2
   UPDATE t_goods SET status=2;

上面这种场景在高并发访问的情况下很可能会出现问题。

前面已经提到，只有当 goods status 为1时才能对该商品下单，上面第一步操作中，查询出来的商品 status 为1。但是当我们执行第三步 Update 操作的时候，有可能出现其他人先一步对商品下单把 goods status 修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得数据不一致。所以说这种方式是不安全的。

#### 2.使用悲观锁来实现

在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出 goods 信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么在这个过程中，因为 goods 被锁了，就不会出现有第三者来对其进行修改了。

注：要使用悲观锁，我们必须关闭 mysql 数据库的自动提交属性，因为 MySQL 默认使用 autocommit 模式，也就是说，当你执行一个更新操作后，MySQL 会立刻将结果进行提交。

我们可以使用命令设置 MySQL 为非 autocommit 模式：

SET AUTOCOMMIT=0;

设置完 autocommit 后，我们就可以执行我们的正常业务了。具体如下：

1. 开始事务
   BEGIN;
2. 查询出商品信息
   SELECT status FROM t_goods WHERE id=1 FOR UPDATE;
3. 根据商品信息生成订单
   INSERT INTO t_orders (id,goods_id) VALUES (null,1);
4. 修改商品 status 为2
   UPDATE t_goods SET status=2 WHERE id = 1;
5. 提交事务
   COMMIT;

注：上面的 BEGIN/COMMIT 为事务的开始和结束，因为在前一步我们关闭了 mysql 的 autocommit，所以需要手动控制事务的提交，在这里就不细表了。

上面的第一步我们执行了一次查询操作：SELECT status FROM t_goods WHERE id=1 FOR UPDATE;

与普通查询不一样的是，我们使用了 SELECT…FOR UPDATE 的方式，这样就通过数据库实现了悲观锁。此时在 t_goods表中， id 为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。
