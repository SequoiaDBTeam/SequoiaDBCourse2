---
show: step
version: 1.0 

---

## 课程介绍

本课程将带领您在已经部署 SequoiaDB 巨杉数据库引擎及创建了 MySQL 实例的环境中，熟悉MySQL的事务和锁机制

#### 请点击右侧选择使用的实验环境

#### 实验环境

课程使用的实验环境为 Ubuntu Linux 16.04 64 位版本。SequoiaDB 数据库引擎以及 SequoiaSQL-MySQL 实例均为 3.4 版本。

#### 概述

**事务**

MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务。

**锁**

锁是计算机协调多个进程或纯线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所在有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

## 打开项目

#### 打开idea

打开idea代码开发工具

![1735-110-1.png](https://doc.shiyanlou.com/courses/1735/1207281/6f87a8c93937c3c51f6d4839559de710-0)

#### 打开SSQL-MySQL项目

打开SSQL-MySQL项目，在该课程中完成后续试验

![1735-110-13.png](https://doc.shiyanlou.com/courses/1735/1207281/40a9e7b6fbd5c3853dc09f69d0a06c86-0)

#### 打开lesson10_transactionAndLock包

打开lesson10_transactionAndLock packge，在该packge中完成后续课程。

![1735-1100-1.png](https://doc.shiyanlou.com/courses/1735/1207281/8489ab84f41210e2a0703700542bfbfb-0)

## 事务控制

使用Connection对象来管理事务。java.sql.Connection接口是一个数据库连接对象。它与特定数据库的连接（会话）。执行SQL语句并在连接的上下文中返回结果。

- 开启事务

  ```java
  setAutoCommit(boolean autoCommit)
  //调用该方法设置参数为false，即开启事务
  ```

- 提交事务

  ```java
  commit()
  //当所有sql斗执行完提交事务
  ```

- 回滚事务

  ```java
  rollback()
  //在catch中回滚事务
  ```

## 使用事务

有如下一个M有SQL数据表，利用Java程序：把id=1对应的余额减少500，id=2对应的余额增加500

![1586224654832](C:\Users\ChengYueyi\AppData\Roaming\Typora\typora-user-images\1586224654832.png)

打开TestMain.java，修改第49行，开启事务

```java
conn.setAutoCommit(false);
```

打开UpdateTest.java，修改第12行TODO中的内容，模拟转帐

```java
String sql1 = "update account set balance = balance - 500 where id = 1";
String sql2 = "update account set balance = balance + 500 where id = 2";
stmt.executeUpdate(sql1);
stmt.executeUpdate(sql2);
```

打开QueryTest.java，修改第8行TODO中的代码为：

```java
stmt = conn.createStatement();
String sql = "SELECT * from account;";
rs = stmt.executeQuery(sql);
while (rs.next()) {
    for (int i = 1; i <= rs.getMetaData().getColumnCount() ; i++) {
        System.out.print(rs.getString(i)+"\t");
    }
    System.out.println();
}
```

打开TestMain.java，修改第54行，提交事务

```java
conn.commit();
```

修改TestMain.java的第64行，如果有错误，回滚事务

```java
conn.rollback();
```

![1735-1100-2.png](https://doc.shiyanlou.com/courses/1735/1207281/a1058210b3b68bb327c0df8b8730e782-0)

右键TransLockMainTest，选择Edit，修改参数为transaction

![1735-1100-3.png](https://doc.shiyanlou.com/courses/1735/1207281/88b4488ff1969ca405d42cf6707fab5a-0)

![1735-1100-4.png](https://doc.shiyanlou.com/courses/1735/1207281/3e26c7be96183e4b2eb66b4fb2471ddf-0)

右键TransLockMainTest，选择Run，执行代码

![1735-1100-5.png](https://doc.shiyanlou.com/courses/1735/1207281/c00ee28d4199589a0845bf25aa9235a6-0)

查看结果

​			1	LeeHua	500	
​			2	Tom	1500	

模拟转帐失败，事务回滚场景

打开UpdateTest.java，修改第TODO中的内容为

```java
String sql1 = "update account set balance = balance - 500 where id = 1";
String sql2 = "update account set balance = balance + 500 where id = 2";
stmt.executeUpdate(sql1);
int i = 1 / 0; //模拟异常
stmt.executeUpdate(sql2);
```

右键TransLockMainTest，选择Run，执行代码

![1735-1100-5.png](https://doc.shiyanlou.com/courses/1735/1207281/c00ee28d4199589a0845bf25aa9235a6-0)

程序报错，最终转帐过程回滚

## 事务原子性

> 事务内的每个内容不可分割，是一个统一的整体。或同时进行或同时消亡。
>
> 验证步骤：写入两条记录分别存放在不同物理服务器，执行更新操作并rollback，确保数据恢复原始状态

环境中已经创建了employee表，表中记录分别存放在不同物理服务器

打开QueryTest.java，修改第9行内容

```java
stmt = conn.createStatement();
String sql = "SELECT * from employee;";
rs = stmt.executeQuery(sql);
while (rs.next()) {
    for (int i = 1; i <= rs.getMetaData().getColumnCount() ; i++) {
        System.out.print(rs.getString(i)+"\t");
    }
    System.out.println();
}
```

> 查看employee中的记录

打开TransLockMainTest.java，修改atomicityTest()方法中的，第83行内容，开启事务

```java
conn.setAutoCommit(false);
```

打开UpdateTest.java，修改TODO中的内容

```java
stmt = conn.createStatement();
String sql1 = "update employee set age = 28 where empno = 10001";
String sql2 = "update employee set age = 20 where empno = 10004";
stmt.executeUpdate(sql1);
int i = 1 / 0;
stmt.executeUpdate(sql2);
```

打开TransLockMainTest.java，修改atomicityTest()方法中的第88行，回滚

```java
conn.rollback();
```

右键TransLockMainTest，选择Edit，修改参数为atomicity

![1735-1100-3.png](https://doc.shiyanlou.com/courses/1735/1207281/88b4488ff1969ca405d42cf6707fab5a-0)

![1735-1100-6.png](https://doc.shiyanlou.com/courses/1735/1207281/d7b9e934a8c6ea8b7f6bfe7c506b9fc3-0)

右键TransLockMainTest，选择Run，执行代码

![1735-1100-5.png](https://doc.shiyanlou.com/courses/1735/1207281/c00ee28d4199589a0845bf25aa9235a6-0)

查看结果，发现前后数据一致

## 事务隔离性

> 事务的隔离性指的是几个事务同时执行，事务a不应该干扰到事务b内的操作（在并发过程中很有可能会发生事务间的影响，例如脏读、不可重复读等。需要在编程的时候选择适当的方式进行选择）
>
> 验证步骤：
>
> 1.开启事务A
>
> 2.开始事务B
>
> 3.在事务B中插入一条记录，不提交
>
> 4.在事务A中查看该条数据是否变化
>
> 5.提交事务B
>
> 6.在事务A中查看该条数据是否变化

打开TransLockMainTest.java，修改isolationTest()方法的第121、122行内容，开启事务A，开启事务B

```java
conn.setAutoCommit(false);
conn2.setAutoCommit(false);
```

打开UpdateTest.java，修改TODO中内容为

```java
stmt = conn.createStatement();
String sql1 = "update employee set age = 28 where empno = 10001";
stmt.executeUpdate(sql1);
```

在事务B修改后，查看事务A中的数据

提交事务B，打开TransLockMainTest.java，修改isolationTest方法第130行内容为

```java
conn2.commit();
```

事务B提交后，查看事务A中的数据

查看结果

![1735-1100-7.png](https://doc.shiyanlou.com/courses/1735/1207281/2e8ec5a088d22c473c674666036e65d9-0)

## 悲观锁

悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

#### 使用场景举例

商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单时必须确保该商品status为1。假设商品的id为1。

#### 1.如果不采用锁，那么操作方法如下

```sql
//1.查询出商品信息
select status from t_goods where id=1;

//2.根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);

//3.修改商品status为2
update t_goods set status=2;
```

上面这种场景在高并发访问的情况下很可能会出现问题。

前面已经提到，只有当goods status为1时才能对该商品下单，上面第一步操作中，查询出来的商品status为1。但是当我们执行第三步Update操作的时候，有可能出现其他人先一步对商品下单把goods status修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得数据不一致。所以说这种方式是不安全的。

#### 2.使用悲观锁来实现

在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出goods信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么在这个过程中，因为goods被锁定了，就不会出现有第三者来对其进行修改了。

注：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。

我们可以使用命令设置MySQL为非autocommit模式：

set autocommit=0;

设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：

```sql
//0.开始事务
begin;/begin work;/start transaction; (三者选一就可以)

//1.查询出商品信息
select status from t_goods where id=1 for update;

//2.根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);

//3.修改商品status为2
update t_goods set status=2;

//4.提交事务
commit;/commit work;
```

注：上面的begin/commit为事务的开始和结束，因为在前一步我们关闭了mysql的autocommit，所以需要手动控制事务的提交，在这里就不细表了。

上面的第一步我们执行了一次查询操作：select status from t_goods where id=1 for update;

与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。
